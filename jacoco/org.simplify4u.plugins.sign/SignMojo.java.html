<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SignMojo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Sign Maven Plugin</a> &gt; <a href="index.source.html" class="el_package">org.simplify4u.plugins.sign</a> &gt; <span class="el_source">SignMojo.java</span></div><h1>SignMojo.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2020 Slawomir Jaranowski
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.simplify4u.plugins.sign;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Function;
import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import org.apache.maven.project.MavenProjectHelper;
import org.apache.maven.project.artifact.ProjectArtifact;
import org.apache.maven.rtinfo.RuntimeInformation;
import org.eclipse.aether.transform.FileTransformer;
import org.simplify4u.plugins.sign.openpgp.PGPKeyInfo;
import org.simplify4u.plugins.sign.openpgp.PGPSigner;

/**
 * Creates OpenPGP signatures for all of the project's artifacts.
 *
 * @author Slawomir Jaranowski
 * @since 0.1.0
 */
<span class="nc" id="L55">@Slf4j</span>
@Mojo(name = &quot;sign&quot;, defaultPhase = LifecyclePhase.VERIFY, threadSafe = true)
<span class="nc" id="L57">public class SignMojo extends AbstractMojo {</span>

    @Inject
    private MavenProject project;

    @Inject
    private MavenSession session;

    /**
     * &lt;p&gt;&lt;code&gt;keyId&lt;/code&gt; used for signing. If not provided first key from &lt;code&gt;keyFile&lt;/code&gt; will be taken.&lt;/p&gt;
     *
     * @since 0.1.0
     */
    @Parameter(property = &quot;sign.keyId&quot;)
    private String keyId;

    /**
     * &lt;p&gt;&lt;code&gt;passphrase&lt;/code&gt; to decrypt private signing key.&lt;/p&gt;
     *
     * &lt;p&gt;Provided key can be stored in plain text, in this case &lt;code&gt;keyPass&lt;/code&gt; can be empty.&lt;/p&gt;
     *
     * &lt;p&gt;This value can be delivered by environment variable &lt;code&gt;SIGN_KEY_PASS&lt;/code&gt;.&lt;/p&gt;
     *
     * @since 0.1.0
     */
    @Parameter(property = &quot;sign.keyPass&quot;)
    private String keyPass;

    /**
     * &lt;p&gt;File with &lt;code&gt;private key&lt;/code&gt; used for signing.&lt;/p&gt;
     *
     * &lt;p&gt;This value can be delivered by environment variable &lt;code&gt;SIGN_KEY&lt;/code&gt;.
     * Environment variable must contain private key content.&lt;/p&gt;
     *
     * &lt;p&gt;Key can by created and exported by:&lt;/p&gt;
     * &lt;pre&gt;
     *      gpg --armor --export-secret-keys
     * &lt;/pre&gt;
     * &lt;p&gt;
     *
     * @since 0.1.0
     */
    @Parameter(property = &quot;sign.keyFile&quot;, defaultValue = &quot;${user.home}/.m2/sign-key.asc&quot;)
    private File keyFile;

    @Inject
    private MavenProjectHelper projectHelper;

    @Inject
    private RuntimeInformation rtInfo;

    @Inject
    private PGPSigner pgpSigner;


    @Override
    public void execute() {

<span class="nc" id="L115">        PGPKeyInfo keyInfo = PGPKeyInfo.builder()</span>
<span class="nc" id="L116">                .keyId(keyId)</span>
<span class="nc" id="L117">                .keyPass(keyPass)</span>
<span class="nc" id="L118">                .keyFile(keyFile)</span>
<span class="nc" id="L119">                .build();</span>

<span class="nc" id="L121">        pgpSigner.setKeyInfo(keyInfo);</span>

        // collect artifact to sign
<span class="nc" id="L124">        Set&lt;Artifact&gt; artifactsToSign = new HashSet&lt;&gt;();</span>

<span class="nc" id="L126">        artifactsToSign.add(new ProjectArtifact(project));</span>
<span class="nc" id="L127">        artifactsToSign.add(project.getArtifact());</span>
<span class="nc" id="L128">        artifactsToSign.addAll(project.getAttachedArtifacts());</span>

        Function&lt;Artifact, List&lt;SignResult&gt;&gt; signMethod;

<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (rtInfo.isMavenVersion(&quot;[3.7.0,)&quot;)) {</span>
<span class="nc" id="L133">            signMethod = this::signArtifact;</span>
        } else {
<span class="nc" id="L135">            signMethod = this::signArtifact36;</span>
        }

        // sign and attach signature to project
<span class="nc" id="L139">        artifactsToSign.stream()</span>
<span class="nc" id="L140">                .filter(SignMojo::verifyArtifact)</span>
<span class="nc" id="L141">                .map(signMethod)</span>
<span class="nc" id="L142">                .flatMap(List::stream)</span>
<span class="nc" id="L143">                .forEach(this::attachSignResult);</span>
<span class="nc" id="L144">    }</span>

    private static boolean verifyArtifact(Artifact artifact) {

<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (artifact == null) {</span>
<span class="nc" id="L149">            throw new SignMojoException(&quot;null artifacts ...&quot;);</span>
        }

<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (artifact.getFile() == null) {</span>
<span class="nc" id="L153">            throw new SignMojoException(&quot;Artifact: &quot; + artifact + &quot; has no file&quot;);</span>
        }

<span class="nc" id="L156">        return true;</span>
    }

    private List&lt;SignResult&gt; signArtifact36(Artifact artifact) {

<span class="nc" id="L161">        try (InputStream artifactInputStream = new BufferedInputStream(new FileInputStream(artifact.getFile()))) {</span>
<span class="nc" id="L162">            return Collections.singletonList(makeSignature(artifactInputStream,</span>
<span class="nc" id="L163">                    artifact.getArtifactId(),</span>
<span class="nc" id="L164">                    artifact.getClassifier(),</span>
<span class="nc" id="L165">                    artifact.getArtifactHandler().getExtension()));</span>
<span class="nc" id="L166">        } catch (IOException e) {</span>
<span class="nc" id="L167">            throw new SignMojoException(e);</span>
        }
    }

    /**
     * Sign given artifact. In result we can have multiple signatures, transformers can produce multiple output for one
     * artifact.
     * &lt;p&gt;
     * This method ask transformers for inputStream for all artifact mutations, and sign each stream.
     *
     * @param artifact artifact to sign
     *
     * @return sign result
     */
    private List&lt;SignResult&gt; signArtifact(Artifact artifact) {
<span class="nc" id="L182">        LOGGER.info(&quot;Signing artifact: {}&quot;, artifact);</span>

<span class="nc" id="L184">        org.eclipse.aether.artifact.Artifact srcArtifact = new org.eclipse.aether.artifact.DefaultArtifact(</span>
<span class="nc" id="L185">                artifact.getGroupId(),</span>
<span class="nc" id="L186">                artifact.getArtifactId(),</span>
<span class="nc" id="L187">                artifact.getClassifier(),</span>
<span class="nc" id="L188">                artifact.getArtifactHandler().getExtension(),</span>
<span class="nc" id="L189">                artifact.getVersion(),</span>
                null,
<span class="nc" id="L191">                artifact.getFile());</span>

<span class="nc" id="L193">        Collection&lt;FileTransformer&gt; transformersForArtifact = session.getRepositorySession().getFileTransformerManager()</span>
<span class="nc" id="L194">                .getTransformersForArtifact(srcArtifact);</span>

<span class="nc" id="L196">        List&lt;SignResult&gt; result = new ArrayList&lt;&gt;();</span>

        try {
<span class="nc bnc" id="L199" title="All 2 branches missed.">            if (transformersForArtifact.isEmpty()) {</span>
<span class="nc" id="L200">                try (InputStream artifactInputStream = new BufferedInputStream(</span>
<span class="nc" id="L201">                        new FileInputStream(srcArtifact.getFile()))) {</span>
<span class="nc" id="L202">                    result.add(makeSignature(artifactInputStream,</span>
<span class="nc" id="L203">                            srcArtifact.getArtifactId(),</span>
<span class="nc" id="L204">                            srcArtifact.getClassifier(),</span>
<span class="nc" id="L205">                            srcArtifact.getExtension()));</span>
                }
            } else {
<span class="nc bnc" id="L208" title="All 2 branches missed.">                for (FileTransformer fileTransformer : transformersForArtifact) {</span>
<span class="nc" id="L209">                    org.eclipse.aether.artifact.Artifact dstArtifact = fileTransformer.transformArtifact(srcArtifact);</span>
<span class="nc" id="L210">                    result.add(makeSignature(fileTransformer.transformData(srcArtifact.getFile()),</span>
<span class="nc" id="L211">                            dstArtifact.getArtifactId(),</span>
<span class="nc" id="L212">                            dstArtifact.getClassifier(),</span>
<span class="nc" id="L213">                            dstArtifact.getExtension()));</span>
<span class="nc" id="L214">                }</span>
            }
<span class="nc" id="L216">        } catch (IOException e) {</span>
<span class="nc" id="L217">            throw new SignMojoException(e);</span>
<span class="nc" id="L218">        }</span>

<span class="nc" id="L220">        return result;</span>
    }

    /**
     * Sign given input stream. In result we will have file with signature.
     *
     * @param inputStream data to sign
     * @param artifactId  used for build filename
     * @param classifier  used for build filename
     * @param extension   used for build filename
     *
     * @return result of signing
     */
    private SignResult makeSignature(InputStream inputStream, String artifactId, String classifier, String extension) {

<span class="nc" id="L235">        String targetExt = extension + &quot;.asc&quot;;</span>

<span class="nc" id="L237">        String targetName = artifactId;</span>
<span class="nc bnc" id="L238" title="All 4 branches missed.">        if (classifier != null &amp;&amp; !classifier.isEmpty()) {</span>
<span class="nc" id="L239">            targetName += &quot;-&quot; + classifier;</span>
        }
<span class="nc" id="L241">        targetName += &quot;.&quot; + targetExt;</span>

<span class="nc" id="L243">        Path target = Paths.get(project.getBuild().getDirectory(), targetName);</span>

<span class="nc" id="L245">        pgpSigner.sign(inputStream, target);</span>

<span class="nc" id="L247">        return new SignResult(classifier, targetExt, target.toFile());</span>
    }

    /**
     * Attache sign result to project.
     */
    private void attachSignResult(SignResult signResult) {
<span class="nc" id="L254">        LOGGER.info(&quot;Attach signature: {}&quot;, signResult);</span>

<span class="nc" id="L256">        projectHelper</span>
<span class="nc" id="L257">                .attachArtifact(project, signResult.getExtension(), signResult.getClassifier(), signResult.getFile());</span>
<span class="nc" id="L258">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>